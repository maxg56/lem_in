<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lem-in Hexagonal Visualizer</title>
    <style>
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e1e2e, #2a2a3e);
            color: #e0e0e0;
            overflow: hidden;
        }

        #container {
            display: flex;
            height: 100vh;
        }

        #canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #visualization-canvas {
            background: #0f0f1a;
            cursor: grab;
        }

        #visualization-canvas:active {
            cursor: grabbing;
        }

        #control-panel {
            width: 300px;
            background: rgba(30, 30, 50, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            overflow-y: auto;
            border-left: 2px solid #4a4a6a;
        }

        .panel-section {
            margin-bottom: 25px;
            background: rgba(40, 40, 60, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #5a5a7a;
        }

        .panel-section h3 {
            margin: 0 0 15px 0;
            color: #64b5f6;
            font-size: 16px;
        }

        .button {
            background: linear-gradient(135deg, #4a6fa5, #5a7fb5);
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 5px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            width: calc(100% - 10px);
        }

        .button:hover {
            background: linear-gradient(135deg, #5a7fb5, #6a8fc5);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .button:active {
            transform: translateY(0);
        }

        .button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        select, input {
            background: #2a2a3e;
            color: #e0e0e0;
            border: 1px solid #5a5a7a;
            padding: 8px;
            border-radius: 5px;
            width: 100%;
            margin: 5px 0;
        }

        .stats {
            list-style: none;
            padding: 0;
        }

        .stats li {
            padding: 5px 0;
            border-bottom: 1px solid #3a3a5a;
        }

        .stats li:last-child {
            border-bottom: none;
        }

        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
            font-weight: bold;
        }

        .status.success {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid #4caf50;
            color: #4caf50;
        }

        .status.error {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid #f44336;
            color: #f44336;
        }

        .status.info {
            background: rgba(33, 150, 243, 0.2);
            border: 1px solid #2196f3;
            color: #2196f3;
        }

        .controls-help {
            font-size: 12px;
            color: #aaa;
            margin-top: 20px;
            line-height: 1.4;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            display: none;
        }

        .path-info {
            background: rgba(80, 120, 200, 0.2);
            border: 1px solid #5078c8;
            border-left: 4px solid #5078c8;
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .path-info:hover {
            background: rgba(80, 120, 200, 0.3);
            transform: translateX(2px);
        }

        .simulation-controls {
            display: none;
        }

        .simulation-controls.active {
            display: block;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: #333;
            border-radius: 5px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #8bc34a);
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container">
            <canvas id="visualization-canvas"></canvas>
            <div id="loading">
                <div>Loading...</div>
            </div>
        </div>
        
        <div id="control-panel">
            <div class="panel-section">
                <h3>üó∫Ô∏è Map Selection</h3>
                <select id="map-select">
                    <option value="">Select a map...</option>
                </select>
                <button class="button" onclick="loadSelectedMap()">Load Map</button>
            </div>

            <div class="panel-section">
                <h3>üìä Map Statistics</h3>
                <ul class="stats" id="map-stats">
                    <li>Rooms: <span id="room-count">0</span></li>
                    <li>Connections: <span id="connection-count">0</span></li>
                    <li>Ants: <span id="ant-count">0</span></li>
                    <li>Zoom: <span id="zoom-level">100%</span></li>
                </ul>
            </div>

            <div class="panel-section">
                <h3>üîç Pathfinding</h3>
                <button class="button" onclick="findAndDisplayPaths()">üîé Analyser les Chemins</button>
                <div id="path-results"></div>
            </div>

            <div class="panel-section simulation-controls" id="simulation-panel">
                <h3>üêú Simulation</h3>
                <button class="button" onclick="runFullSimulation()">üöÄ Ex√©cuter la Simulation</button>
                <button class="button" onclick="pauseSimulation()">‚è∏Ô∏è Pause/Reprendre</button>
                <button class="button" onclick="resetSimulation()">üîÑ Reset</button>
                <div>
                    <label>Speed: <span id="speed-value">1x</span></label>
                    <input type="range" id="speed-slider" min="0.1" max="3" step="0.1" value="1" onchange="updateSpeed()">
                </div>
                
                <div class="progress-bar">
                    <div class="progress-fill" id="simulation-progress" style="width: 0%"></div>
                </div>
                
                <div id="simulation-stats">
                    <small>Turn: <span id="current-turn">0</span></small><br>
                    <small>Finished: <span id="finished-ants">0</span>/<span id="total-ants">0</span></small>
                </div>
            </div>

            <div class="panel-section">
                <h3>üéÆ Controls</h3>
                <div class="controls-help">
                    <strong>Mouse:</strong><br>
                    ‚Ä¢ Wheel: Zoom in/out<br>
                    ‚Ä¢ Drag: Pan view<br>
                    ‚Ä¢ Click: Select room<br><br>
                    
                    <strong>Keyboard:</strong><br>
                    ‚Ä¢ R: Reset view<br>
                    ‚Ä¢ Space: Start simulation<br>
                    ‚Ä¢ +/-: Zoom<br>
                </div>
            </div>

            <div id="status-messages"></div>
        </div>
    </div>

    <script>
        // Global state
        let canvas, ctx;
        let mapData = null;
        let currentPaths = [];
        let simulationData = null;
        let animationId = null;
        let isSimulating = false;
        let isPaused = false;
        let currentTurn = 0;
        let simulationSpeed = 1;
        let ants = [];
        let simulationTimer = null; // Timer for simulation steps
        
        // View state
        let zoom = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        
        // Colors
        const COLORS = {
            background: '#0f0f1a',
            room: '#3a4a6a',
            roomBorder: '#5a6a8a',
            start: '#4caf50',
            end: '#f44336',
            path: '#2196f3',
            connection: '#4a5a7a',
            pathConnection: '#64b5f6',
            text: '#e0e0e0',
            ant: '#ff5722',
            selected: '#ffeb3b'
        };

        // Path colors - each path gets a different color
        const PATH_COLORS = [
            '#ff6b6b', // Red
            '#4ecdc4', // Teal
            '#45b7d1', // Blue
            '#96ceb4', // Green
            '#ffeaa7', // Yellow
            '#dda0dd', // Plum
            '#98d8c8', // Mint
            '#f7dc6f', // Light Yellow
            '#bb8fce', // Purple
            '#85c1e9', // Sky Blue
            '#f8c471', // Orange
            '#82e0aa', // Light Green
            '#f1948a', // Light Red
            '#85c1e9', // Light Blue
            '#d7bde2'  // Light Purple
        ];

        // Initialize
        window.onload = function() {
            initCanvas();
            loadAvailableMaps();
            setupEventListeners();
            
            // Start animation loop
            animate();
        };

        function initCanvas() {
            canvas = document.getElementById('visualization-canvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas size
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        }

        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        function setupEventListeners() {
            // Mouse events
            canvas.addEventListener('wheel', handleWheel);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            
            // Keyboard events
            window.addEventListener('keydown', handleKeyDown);
        }

        function handleWheel(e) {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            zoom = Math.max(0.1, Math.min(5, zoom * zoomFactor));
            updateZoomDisplay();
            drawVisualization(); // Add this line
        }

        function handleMouseDown(e) {
            isDragging = true;
            dragStart.x = e.clientX;
            dragStart.y = e.clientY;
        }

        function handleMouseMove(e) {
            if (isDragging) {
                const dx = e.clientX - dragStart.x;
                const dy = e.clientY - dragStart.y;
                offsetX += dx;
                offsetY += dy;
                dragStart.x = e.clientX;
                dragStart.y = e.clientY;
                drawVisualization(); // Add this line
            }
        }

        function handleMouseUp(e) {
            isDragging = false;
        }

        function handleKeyDown(e) {
            switch(e.key) {
                case 'r':
                case 'R':
                    resetView();
                    break;
                case ' ':
                    e.preventDefault();
                    if (currentPaths.length > 0) {
                        startSimulation();
                    }
                    break;
                case '+':
                case '=':
                    zoom = Math.min(5, zoom * 1.1);
                    updateZoomDisplay();
                    drawVisualization(); // Add this line
                    break;
                case '-':
                    zoom = Math.max(0.1, zoom * 0.9);
                    updateZoomDisplay();
                    drawVisualization(); // Add this line
                    break;
            }
        }

        async function loadAvailableMaps() {
            try {
                const response = await fetch('/api/maps');
                const data = await response.json();
                
                if (data.success && data.data && data.data.maps) {
                    const select = document.getElementById('map-select');
                    select.innerHTML = '<option value="">Select a map...</option>';
                    
                    data.data.maps.forEach(map => {
                        const option = document.createElement('option');
                        option.value = map;
                        option.textContent = map;
                        select.appendChild(option);
                    });
                    
                    showStatus(`Loaded ${data.data.maps.length} maps`, 'success');
                } else {
                    showStatus('No maps found or invalid response', 'error');
                }
            } catch (error) {
                console.error('Error loading maps:', error);
                showStatus('Failed to load maps: ' + error.message, 'error');
            }
        }

        async function loadSelectedMap() {
            const select = document.getElementById('map-select');
            const filename = select.value;
            
            if (!filename) {
                showStatus('Please select a map', 'error');
                return;
            }

            showLoading(true);
            
            try {
                const response = await fetch('/api/load_map', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ filename: filename })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    mapData = data.data;
                    currentPaths = [];
                    resetSimulation();
                    updateMapStats();
                    calculateRoomPositions();
                    drawVisualization(); // Add this line to render the map
                    showStatus('Map loaded successfully', 'success');
                } else {
                    showStatus('Failed to load map: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('Network error: ' + error.message, 'error');
            } finally {
                showLoading(false);
            }
        }

        function updateMapStats() {
            if (!mapData) return;
            
            document.getElementById('room-count').textContent = mapData.rooms.length;
            document.getElementById('connection-count').textContent = mapData.connections.length;
            document.getElementById('ant-count').textContent = mapData.ant_count;
            updateZoomDisplay();
        }

        function updateZoomDisplay() {
            document.getElementById('zoom-level').textContent = Math.round(zoom * 100) + '%';
        }

        function calculateRoomPositions() {
            if (!mapData || !mapData.rooms.length) return;
            
            // Find bounds
            let minX = Math.min(...mapData.rooms.map(r => r.x));
            let maxX = Math.max(...mapData.rooms.map(r => r.x));
            let minY = Math.min(...mapData.rooms.map(r => r.y));
            let maxY = Math.max(...mapData.rooms.map(r => r.y));
            
            const rangeX = maxX - minX || 1;
            const rangeY = maxY - minY || 1;
            
            const padding = 100;
            const scaleX = (canvas.width - 2 * padding) / rangeX;
            const scaleY = (canvas.height - 2 * padding) / rangeY;
            const scale = Math.min(scaleX, scaleY) * 0.8;
            
            // Calculate screen positions
            mapData.rooms.forEach(room => {
                room.screenX = ((room.x - minX) / rangeX) * scale * rangeX + padding;
                room.screenY = ((room.y - minY) / rangeY) * scale * rangeY + padding;
            });
            
            resetView();
        }

        function resetView() {
            if (!mapData) return;
            
            // Center the view
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            const roomsCenterX = mapData.rooms.reduce((sum, r) => sum + r.screenX, 0) / mapData.rooms.length;
            const roomsCenterY = mapData.rooms.reduce((sum, r) => sum + r.screenY, 0) / mapData.rooms.length;
            
            offsetX = centerX - roomsCenterX;
            offsetY = centerY - roomsCenterY;
            zoom = 1;
            updateZoomDisplay();
            drawVisualization(); // Add this line to render after reset
        }

        async function findAndDisplayPaths() {
            if (!mapData) {
                showStatus('Please load a map first', 'error');
                return;
            }

            showLoading(true);
            showStatus('Analyzing paths with C executable...', 'info');
            
            try {
                const response = await fetch('/api/find_path', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ algorithm: 'optimal' })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    currentPaths = data.paths || data.data?.paths || [];
                    displayColoredPathResults(currentPaths);
                    drawVisualization();
                    
                    if (currentPaths.length > 0) {
                        document.getElementById('simulation-panel').classList.add('active');
                        showStatus(`Found ${currentPaths.length} optimized path(s)`, 'success');
                    } else {
                        showStatus('No paths found', 'info');
                    }
                } else {
                    showStatus('Pathfinding failed: ' + (data.error || 'Unknown error'), 'error');
                }
            } catch (error) {
                showStatus('Network error: ' + error.message, 'error');
            } finally {
                showLoading(false);
            }
        }

        async function runFullSimulation() {
            if (!mapData) {
                showStatus('Please load a map first', 'error');
                return;
            }

            showLoading(true);
            showStatus('Running full simulation with C executable...', 'info');
            
            try {
                // First get paths if we don't have them
                if (currentPaths.length === 0) {
                    await findAndDisplayPaths();
                }

                // Then run the full simulation
                const response = await fetch('/api/simulate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ paths: currentPaths })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    simulationData = data.simulation || data.data?.simulation;
                    initializeAntsWithColors();
                    
                    // Reset simulation state
                    isSimulating = true;
                    isPaused = false;
                    currentTurn = 0;
                    
                    if (simulationTimer) {
                        clearTimeout(simulationTimer);
                    }
                    
                    updateSimulationStats();
                    showStatus('Full simulation started - watch the ant animations!', 'success');
                    
                    // Start the simulation
                    updateSimulation();
                } else {
                    showStatus('Simulation failed: ' + (data.error || 'Unknown error'), 'error');
                }
            } catch (error) {
                showStatus('Network error: ' + error.message, 'error');
            } finally {
                showLoading(false);
            }
        }

        function displayColoredPathResults(paths) {
            const container = document.getElementById('path-results');
            container.innerHTML = '';
            
            paths.forEach((path, index) => {
                const pathColor = PATH_COLORS[index % PATH_COLORS.length];
                const pathDiv = document.createElement('div');
                pathDiv.className = 'path-info';
                pathDiv.style.borderLeft = `4px solid ${pathColor}`;
                pathDiv.innerHTML = `
                    <div style="display: flex; align-items: center; margin-bottom: 5px;">
                        <div style="width: 16px; height: 16px; background: ${pathColor}; border-radius: 50%; margin-right: 8px;"></div>
                        <strong>Path ${index + 1}:</strong> ${path.length} rooms
                    </div>
                    <small>${path.join(' ‚Üí ')}</small>
                `;
                container.appendChild(pathDiv);
            });
        }

        function initializeAntsWithColors() {
            ants = [];
            const startRoom = mapData.rooms.find(r => r.is_start);
            
            if (startRoom) {
                // Initialize all ants with their IDs, starting at the start room
                for (let i = 0; i < mapData.ant_count; i++) {
                    const pathIndex = currentPaths.length > 0 ? i % currentPaths.length : 0;
                    ants.push({
                        id: i + 1,
                        pathColor: currentPaths.length > 0 ? PATH_COLORS[pathIndex % PATH_COLORS.length] : COLORS.ant,
                        currentRoom: startRoom.name,
                        x: startRoom.screenX,
                        y: startRoom.screenY,
                        targetX: startRoom.screenX,
                        targetY: startRoom.screenY,
                        animationProgress: 1, // Start with complete animation
                        finished: false
                    });
                }
            }
            
            document.getElementById('total-ants').textContent = ants.length;
        }

        async function findPath(algorithm) {
            if (!mapData) {
                showStatus('Please load a map first', 'error');
                return;
            }

            showLoading(true);
            
            try {
                const response = await fetch('/api/find_path', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ algorithm: algorithm })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    currentPaths = data.paths || data.data?.paths || [];
                    displayColoredPathResults(currentPaths);
                    drawVisualization();
                    
                    if (currentPaths.length > 0) {
                        document.getElementById('simulation-panel').classList.add('active');
                        showStatus(`Found ${currentPaths.length} path(s)`, 'success');
                    } else {
                        showStatus('No paths found', 'info');
                    }
                } else {
                    showStatus('Pathfinding failed: ' + (data.error || 'Unknown error'), 'error');
                }
            } catch (error) {
                showStatus('Network error: ' + error.message, 'error');
            } finally {
                showLoading(false);
            }
        }

        async function startSimulation() {
            if (!currentPaths.length) {
                showStatus('Find paths first', 'error');
                return;
            }

            showLoading(true);
            
            try {
                const response = await fetch('/api/simulate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ paths: currentPaths })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    simulationData = data.simulation;
                    initializeAnts();
                    isSimulating = true;
                    isPaused = false;
                    currentTurn = 0;
                    updateSimulationStats();
                    showStatus('Simulation started', 'success');
                } else {
                    showStatus('Simulation failed: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('Network error: ' + error.message, 'error');
            } finally {
                showLoading(false);
            }
        }

        function initializeAnts() {
            ants = [];
            const startRoom = mapData.rooms.find(r => r.is_start);
            
            if (startRoom) {
                // Initialize all ants with their IDs, starting at the start room
                for (let i = 0; i < mapData.ant_count; i++) {
                    const pathIndex = currentPaths.length > 0 ? i % currentPaths.length : 0;
                    ants.push({
                        id: i + 1,
                        pathColor: currentPaths.length > 0 ? PATH_COLORS[pathIndex % PATH_COLORS.length] : COLORS.ant,
                        currentRoom: startRoom.name,
                        x: startRoom.screenX,
                        y: startRoom.screenY,
                        targetX: startRoom.screenX,
                        targetY: startRoom.screenY,
                        animationProgress: 1, // Start with complete animation
                        finished: false
                    });
                }
            }
            
            document.getElementById('total-ants').textContent = ants.length;
        }

        function pauseSimulation() {
            if (isSimulating) {
                isPaused = !isPaused;
                if (isPaused) {
                    // Clear the timer when pausing
                    if (simulationTimer) {
                        clearTimeout(simulationTimer);
                        simulationTimer = null;
                    }
                    showStatus('Simulation paused', 'info');
                } else {
                    // Resume simulation
                    showStatus('Simulation resumed', 'info');
                    updateSimulation();
                }
            }
        }

        function resetSimulation() {
            isSimulating = false;
            isPaused = false;
            currentTurn = 0;
            simulationData = null;
            ants = [];
            
            // Clear the timer
            if (simulationTimer) {
                clearTimeout(simulationTimer);
                simulationTimer = null;
            }
            
            currentPaths = [];
            document.getElementById('simulation-panel').classList.remove('active');
            document.getElementById('path-results').innerHTML = '';
            updateSimulationStats();
            drawVisualization(); // Redraw to remove any effects
        }

        function updateSpeed() {
            const slider = document.getElementById('speed-slider');
            simulationSpeed = parseFloat(slider.value);
            document.getElementById('speed-value').textContent = simulationSpeed + 'x';
        }

        function updateSimulationStats() {
            document.getElementById('current-turn').textContent = currentTurn;
            document.getElementById('finished-ants').textContent = ants.filter(a => a.finished).length;
            
            if (simulationData) {
                const progress = (currentTurn / simulationData.total_turns) * 100;
                document.getElementById('simulation-progress').style.width = progress + '%';
            }
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (mapData) {
                drawVisualization();
            }
            
            // Animate ants movement between positions
            if (isSimulating || ants.length > 0) {
                ants.forEach(ant => {
                    if (!ant.finished && ant.animationProgress < 1) {
                        ant.animationProgress += 0.02 * simulationSpeed;
                        if (ant.animationProgress >= 1) {
                            ant.animationProgress = 1;
                        }
                        
                        // Smooth interpolation between current and target position
                        const t = easeInOut(ant.animationProgress);
                        ant.x = ant.x + (ant.targetX - ant.x) * t * 0.15;
                        ant.y = ant.y + (ant.targetY - ant.y) * t * 0.15;
                    }
                });
            }
            
            animationId = requestAnimationFrame(animate);
        }

        function updateSimulation() {
            if (!simulationData || currentTurn >= simulationData.moves.length) {
                if (isSimulating) {
                    isSimulating = false;
                    if (simulationTimer) {
                        clearTimeout(simulationTimer);
                        simulationTimer = null;
                    }
                    showStatus('Simulation completed', 'success');
                }
                return;
            }
            
            if (isPaused) return;
            
            // Get moves for current turn
            const moves = simulationData.moves[currentTurn];
            
            if (moves && typeof moves === 'object') {
                // Format: {antId: roomName, antId: roomName}
                Object.entries(moves).forEach(([antIdStr, roomName]) => {
                    const antId = parseInt(antIdStr);
                    const ant = ants.find(a => a.id === antId);
                    const room = mapData.rooms.find(r => r.name === roomName);
                    
                    if (ant && room) {
                        // Start animation to new position
                        ant.targetX = room.screenX;
                        ant.targetY = room.screenY;
                        ant.animationProgress = 0;
                        ant.currentRoom = roomName;
                        
                        // Check if ant reached the end
                        if (room.is_end) {
                            ant.finished = true;
                        }
                    }
                });
            }
            
            // Update stats
            currentTurn++;
            updateSimulationStats();
            
            // Schedule next turn with animation time
            if (isSimulating && currentTurn < simulationData.moves.length) {
                const delay = Math.max(300, 1500 / simulationSpeed); // Slower for animation
                simulationTimer = setTimeout(() => {
                    updateSimulation();
                }, delay);
            } else if (currentTurn >= simulationData.moves.length) {
                // Simulation finished
                isSimulating = false;
                showStatus('Simulation completed', 'success');
            }
        }

        function easeInOut(t) {
            return t * t * (3 - 2 * t);
        }

        function drawVisualization() {
            if (!mapData || !mapData.rooms) {
                // Clear canvas if no data
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                return;
            }
            
            // Clear canvas first
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            
            // Apply transformations
            ctx.translate(offsetX, offsetY);
            ctx.scale(zoom, zoom);
            
            // Draw connections with path colors
            mapData.connections.forEach(conn => {
                const roomA = mapData.rooms.find(r => r.name === conn.from);
                const roomB = mapData.rooms.find(r => r.name === conn.to);
                
                if (roomA && roomB) {
                    // Check if this connection is part of any path
                    let pathColor = null;
                    let isInPath = false;
                    
                    for (let pathIndex = 0; pathIndex < currentPaths.length; pathIndex++) {
                        const path = currentPaths[pathIndex];
                        const roomAIndex = path.indexOf(roomA.name);
                        const roomBIndex = path.indexOf(roomB.name);
                        
                        if (roomAIndex !== -1 && roomBIndex !== -1 && Math.abs(roomAIndex - roomBIndex) === 1) {
                            pathColor = PATH_COLORS[pathIndex % PATH_COLORS.length];
                            isInPath = true;
                            break;
                        }
                    }
                    
                    ctx.strokeStyle = isInPath ? pathColor : COLORS.connection;
                    ctx.lineWidth = isInPath ? 3 : 2;
                    
                    ctx.beginPath();
                    ctx.moveTo(roomA.screenX, roomA.screenY);
                    ctx.lineTo(roomB.screenX, roomB.screenY);
                    ctx.stroke();
                }
            });
            
            // Draw rooms with path colors
            mapData.rooms.forEach(room => {
                let roomColor = COLORS.room;
                
                // Check if room is in any path and get its color
                for (let pathIndex = 0; pathIndex < currentPaths.length; pathIndex++) {
                    const path = currentPaths[pathIndex];
                    if (path.includes(room.name)) {
                        roomColor = PATH_COLORS[pathIndex % PATH_COLORS.length];
                        break;
                    }
                }
                
                // Room circle
                ctx.beginPath();
                ctx.arc(room.screenX, room.screenY, 20, 0, 2 * Math.PI);
                
                if (room.is_start) {
                    ctx.fillStyle = COLORS.start;
                } else if (room.is_end) {
                    ctx.fillStyle = COLORS.end;
                } else {
                    ctx.fillStyle = roomColor;
                }
                
                ctx.fill();
                ctx.strokeStyle = COLORS.roomBorder;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Room name
                ctx.fillStyle = COLORS.text;
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(room.name, room.screenX, room.screenY + 4);
            });
            
            // Draw ants with their path colors
            if (isSimulating || ants.length > 0) {
                ants.forEach(ant => {
                    if (!ant.finished) {
                        ctx.beginPath();
                        ctx.arc(ant.x, ant.y, 6, 0, 2 * Math.PI);
                        ctx.fillStyle = ant.pathColor || COLORS.ant;
                        ctx.fill();
                        
                        // Ant ID
                        ctx.fillStyle = COLORS.text;
                        ctx.font = '10px sans-serif';
                        ctx.fillText(ant.id.toString(), ant.x + 8, ant.y - 8);
                    }
                });
            }
            
            ctx.restore();
        }

        function showStatus(message, type) {
            const container = document.getElementById('status-messages');
            const statusDiv = document.createElement('div');
            statusDiv.className = `status ${type}`;
            statusDiv.textContent = message;
            
            container.innerHTML = '';
            container.appendChild(statusDiv);
            
            setTimeout(() => {
                statusDiv.remove();
            }, 5000);
        }

        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }
    </script>
</body>
</html>